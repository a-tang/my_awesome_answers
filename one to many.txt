
bin/rails g model answer question:references body:text
    
    # t.references creates an integer field called question_id (Rails convention)
    # which is the foreign key for the answers table to the questions table
    # foreign_key: true automatically creates the foreign_key constraint
    # index: true automatically creates an index on the question_id field


bin/rake db:migrate

changing the constraints can be done on rails rather than on database level

models/answer.rb created
  # by having this `belongs_to` in the model we can easily fetch the question
  # for a given answer by running:
  # ans = Answer.find(14)
  # q   = ans.question
  # belongs_to assumes that the `answers` table has a foreign_key called
  # question_id (Rails convention)
  

models/question update

  # when using `has_many` you must put a symbol for the associated record in
  # plural format
  # you also should provide the :dependent option which can be either:
  # :destroy: which deletes all the associated answers when the question is deleted
  # :nullify: which makes `question_id` NULL for all associated answers
  
bin/rails c

a = q.answers.new(body: "sadf")
a.save
q.answers.reload
OR

a = Answer.new body: "asdf!"
a.question = q
a.save
q.answers.reload
q.destroy

** this will give the following message:

   (0.1ms)  BEGIN
  SQL (0.2ms)  DELETE FROM "answers" WHERE "answers"."id" = $1  [["id", 1]]
  SQL (0.1ms)  DELETE FROM "answers" WHERE "answers"."id" = $1  [["id", 2]]
  SQL (0.4ms)  DELETE FROM "questions" WHERE "questions"."id" = $1  [["id", 115]]
   (27.9ms)  COMMIT

bin/rails g controller answers

update routes.rb
    # the answers routes will be the standard ones prefixed with
    # /questions/:question_id
    # this way when, for instance, we want to create an answer we know the
    # question that it references
    # all the helpers will be the same as before prefixed with `question_`
    
    
    resources :answers, only: [:create, :destroy]
    
    
  this generates new search paths
  
add a form in show.html.erb
<%= form_for [@question, @answer] do |form_helper|  %>
  <%= form_helper.text_area :body %>
  <%= form_helper.submit %>
<% end %>


update show in questions_controller.rb

  def show
    @answer = Answer.new
   end

update answer_controller.rb
  
  def create
    question        = Question.find params[:question_id]
    answer_params   = params.require(:answer).permit(:body)
    answer          = Answer.new answer_params
    answer.question = question
    answer.save
    #render json: params
    redirect_to question_path(question), notice: "Thanks for answering"
  end

set validations to catch errors

models>answer.rb
    validates :body, presence: true

answer_controller

 def create
    @question        = Question.find params[:question_id]
    answer_params    = params.require(:answer).permit(:body)
    @answer          = Answer.new answer_params
    @answer.question = @question
    if @answer.save
      redirect_to question_path(@question), notice: "Thanks for answering"
    else
      flash[:alert] = "not saved"
      # this will render the show.html.erb inside views/questions
      render "/questions/show"
    end
  end
end

update the show.html.erb to show error message!

<%= @answer.errors.full_messages.join(", ") %>


to show answers on the page enter the following in the show.htm.erb

<h2>Answers</h2>
<% @question.answers.each do |ans| %>
  <%= ans.body %>
  <hr>
<% end %>

to delete answers, add the following under each answers

<%= link_to "delete", question_answer_path(@question, ans),
                        data: {confirm: "Are you sure?"},
                        method: :delete %>


                        
update the answers_controller with a 'destroy' method

  def destroy
    question = Question.find params[:question_id]
    answer   = question.answers.find params[:id]
    answer.destroy
    redirect_to question_path(question), notice: "Answer deleted!"
  end
  

CREATE CATEGORY
  
bin/rails g model category name

ADD validations to models\category.rb

class Category < ActiveRecord::Base
   validates :name, presence: true, uniqueness: true
   has_many :questions, dependent: :nullify
end

  bin/rake db:migrate

  bin/rails g migration add_category_references_to_questions category:references

update models>question.rb

  belongs_to :category

update seeds

  10.times do
    Category.create(name: Faker::Hacker.adjective)
  end
  
  
update _form
  <div>
      <%= f.label :category %>
      <%= f.collection_select :category_id, Category.order(:name), :id, :name %>
  </div>
  
  update questions_controller.rb
  
  def question_params
    question_params  = params.require(:question).permit([:title, :body, :category_id])
  end
  

  

